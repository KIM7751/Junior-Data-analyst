- 플라스크는 '프로젝트의 구조를 어떻게 하라'와 같은 규칙이 없기 때문에 프로젝트를 구성할 때 생각을 많이 해야함 

- 앞서 작성한 pybo.py 파일은 pybo 패키지로 변경할 수 있음 

- __init__.py 파일이 pybo.py 파일의 역할을 대신할 것임

- 패키지 안에 구성해야하는 파일과 디렉터리를 먼저 알아보자면 

	1) 데이버 베이스를 처리하는 models.py, 모델 클래스를 정의할 것임

	2) 서버로 전송된 폼을 처리하는 form.py, 웹 브라우저에서 서버로 전송된 폼을 처리할 때, 폼 클래스 정의할 것임

	3) 화면을 구성하는 views 디렉터리, 화면 구성을하는 함수들이 작성된 여러가지 뷰 파일을 저장할 것임 

	4) CSS, 자바스크립트, 이미지 파일을 저장하는 static 디렉터리

	5) HTML 파일을 저장하는 templates 디렉터리, 템플릿 파일을 계속해서 추가

	6) config.py 프로젝트 설정하는 파일, 프로젝트의 환경 변수, 데이터 베이스등의 설정을 저장


-------------------------------------------------------------------------------------------------------------------


- 플라스크앱은 Flask 클래스로 만든 객체를 말함

myproject/pybo.py

app = Flask(__name__)

@app.route('/')
def hello_pybo( ):
	return 'Hello, pybo'

- app 객체를 전역으로 사용하면 프로젝트 규모가 커질수록 문제가 발생할 확률이 높아짐(순환참조 A -> B -> A)

- 애플리케이션 팩토리를 사용(= app 객체를 생성하는 함수)

- pybo.py -> pybo/__init__.py 파일로 대체

- 1장에서 플라스크 기본 앱을 FLASK_APP = pybo로 설정했을때 pybo는 프로젝트 루트에 있는 pybo.py를 가리킴

- 이번에는 pybo 모듈 즉 pybo/__init__.py을 가리켜 코드를 변경하지 않고서도 오류없이 정상 작동

- __init__.py 파일을 열고 create_app 함수 선언하는 방식으로 코드를 수정 

myproject/pybo/__init__.py

	def create_app( ):
	     app = Flask(__name__)
	     @app.route('/')
	     def hello_pybo( ):
		return 'Hello, pybo'
	     return app

- create_app 함수가 app객체를 생성해 반환하도록 코드를 수정, 이때 app 객체가 함수 안에서 사용되므로 hello_pybo함수 포함

- 여기서 사용된 create_app 함수가 애플리케이션 팩토리

※ 함수명으로 다른 것을 사용하면 동작하지 않음, create_app은 플라스크 내부에서 정의된 함수명

-------------------------------------------------------------------------------------------------------------------





