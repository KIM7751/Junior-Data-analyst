기영이의 파이썬 코드 사전

- Matplotlib 그래프 

    -> ax.plot 함수를 두 번 호출시 다시 말에 하나의 ax에 여러 번 그래프를 그리면 그래프를 겹쳐서 그릴 수 있음

    -> line plot 
        
        fig, ax = plt. subplots ( ) -- 괄호 안이 공란일 경우 1개 표시

        x = np.arange(15)

        y = x ** 2                    -- x의 제곱을 의미 

       ax.plot(
	x,  y,
             linestyle = " : "        -- 점선                   (- 직선) (-- 점선) (-. 점과 선이 섞인 선) 
             marker = " * "         -- 지점 별 모양         (. 점) (o 원) (v 역삼각형) (s 네모)
             color = "524FA1"      -- 색깔 지정            (r 빨강) (g 초록) (0.8 0 ~ 1 사이의 투명도, 회색)
        )

     -> 축 경계 조정

         x = np.linespace(0, 10, 1000) -- start, end, step

         fig, ax = plt.subplots( )

         ax.plot(x, np.sin())               -- 사인 그래프

         ax.set_xlim(-2, 12)               -- x축 범위

         ax.set_ylim(-1.5, 1.5)            -- y축 범위

     -> 범례

         x = np.arange(10)

         fig, ax = plt.subplots( )

         ax.plot(x, x, label = 'y=x')

         ax.plot(x, x**2, label = 'y=x^2')

         ax.set_xlabel('x')

         ax.set_ylabel('y')

         ax.legend(loc = 'upper right',     -- 범례 표시, location 위치 - 우측 상단
	         shadow = True,          -- 그림자 표시
	         fancybox = True,        -- 범례 상자 모서리 둥글게 표시
	         borderpad = 2)          -- 범례 내부 상자 크기 

      
      -> Bar plot

         x = np.arange(10)

         fig, ax = plt.subplots(figsize = (12, 4))   -- 가로 12, 세로 4

         ax.bar(x, x*2)

      -> Omit Bar plot

         x = np.random.rand(3)  -- 0 ~ 1 사이의 랜덤값

         y = np.random.rand(3)

         z = np.random.rand(3)

         data = [x, y, z]

         fig, ax = plt.subplots( ) 

         x_ax = np.arange(3)  -- 0, 1, 2

         for i in x_ax : 
	ax.bar(x_ax, data[ i ], bottom = np.sum(data[ : i ], axis = 0))  -- x축, y축, 바닥부터 쌓아올림

         ax.set_xticks(x_ax)   -- x 축 설정
    
         ax.set_xtickslabels(["A", "B", "C"])   -- x 축 라벨링

      -> Histogram

         fig, ax = plt.subplots( )

         data = np.random.randn(1000) -- 1000개의 랜덤한 숫자 추출

         ax.hist(data, bins = 50) -- 1000개의 데이터를 50개의 막대로 나타냄

        

-------------------------------------------------------------------------------------------------------------------------------


- Pandas : 파이썬 라이브러리, 구조화된 데이터를 효과적으로 처리하고 저장, Array 계산에 특화된 NumPy를 기반으로 설계

    -> Series - Numpy의 array가 보강된 형태 Data와 index를 가지고 있음, dtype 인자로 데이터 타입을 지정할 수 있음(dtype = float, int ..), 인덱스 지정, 접근 가능,
	       dic 자료형을 활용해 Series 생성 가능

    -> DataFrame - 여러 개의 Series가 모여 행과 열을 이룬 데이터

    -> .loc 명시적인 인덱스를 참조하는 인덱싱 / 슬라이싱

    -> .iloc 파이썬 스타일의 정수(암묵적인 순서) 인덱스 인덱싱 / 슬라이싱

    -> 칼럼명을 활용해 데이터 선택 가능 ['칼럼명'] = 칼럼명 // [['칼럼명]] = 해당 칼럼 df

    -> 시리즈도 numpy array 처럼 연산자 활용 가능

    -> 간단한 집계로 넘어서서 조건부로 집계 df.groupby('key').sum( ) - df의 'key'로 그룹화해서 합하겠다

    -> aggregate - 합계라는 의미로 한 번의 groupby를 통해서 여러 개 통계함수를 적용시키고 싶을 때 사용
        
	ex) df.groupby('key').aggregate(['min', np.median, max]) - 세 가지 표기 방법 모두 사용 가능
	
	     df.groupby('key')aggregate({'data1' : 'min', 'data2' : np.sum}) - 칼럼 마다 다른 집계 함수 사용 가능 
   
    -> df.groupby('key').apply(lambda x : x.max( ) - x.min( )) - groupby를 통해서 묶인 데이터에 함수 적용 

    -> df.groupby('시도').get_group('충남') - '시도'로 데이터를 그룹화하고 '충남' 데이터만 불러오겠다 

-------------------------------------------------------------------------------------------------------------------------------


- NumPy : 수치적 파이썬, 대규모(많은) 다차원(2차원이상) 배열(데이터 나열)을 다룰 수 있게 도와주는 라이브러리

    -> 데이터의 대부분은 숫자 배열로 볼 수 있음(이미지 = 픽셀의 배열)

    -> 반복문(리스트 - ,콤마로 구분) 없이 배열 처리 가능해 빠른 연산을 지원하고 메모리 효율적 사용

    -> import numpy as np

    -> np.array(range(5)) = [0 1 2 3 4] - 공백으로 구분, type() 자료형 표시 <class 'numpy.ndarray(n-dimensional array)'>

    -> 파이썬 리스트와 달리 같은 데이터 타입만 저장 가능 = 단일 데이터,  np.array(range(5), dtype = float)

    -> ndarray의 차원 관련 속성 - ndim(n차원) , shape(모양), size(크기), dtype(int, float ,,)

    -> np.arange(숫자 시작, 숫자 끝, 간격) = np.arange(1, 13, 1) - 1~12까지의 숫자로 1 간격만큼 


-------------------------------------------------------------------------------------------------------------------------------

- 패키지 : 모듈을 폴더(directory)로 구분하여 관리하는 것, 모듈을 편리하게 관리하기 위해서

    -> import를 이용해서 폴더를 불러온 후 함수 실행  ex) user(폴더).cal(모듈) //// cal.plus

    -> from - import를 사용 , 함수/변수 사용시 .를 써주지 않아도 됨 ex) from user(폴더).cal(모듈) import plus(함수) //// plus( )   
   
   from urllib.request import urlopen

   urlopen( ) : 이 함수에 url을 넣으면 해당 url에 접근한 결과를 얻을 수 있습니다.
   
   read( ) : 결과를 해독하여 문자열로 반환합니다.
   
   decode( ) : 문자열을 특정 인코딩 방식으로 해독합니다. (유니코드, 아스키 코드 등)

-------------------------------------------------------------------------------------------------------------------------------

- 모듈 : 특정 목적을 가진 함수 / 자료의 모임, 모듈 속 사용하려는 함수/변수의 사용법 확인해야함 

   ex) 라면 레시피

   -> import(불러오다) 키워드를 이용해서 모듈 사용

   -> .(dot) 을 쓴 후에 모듈 속 함수 / 변수 사용

   -> 모듈 제작 가능 .py(파이썬 파일)로 만들 수 있음

-------------------------------------------------------------------------------------------------------------------------------

- 매개변수(parameter) : 함수를 정의할 때(만들 때) 넘겨받은 값을 관리하는 변수 -> def solve(a, b): return a * b

- 인자(argument) : 함수를 호출할 때(사용할 때) 함수로 넘겨주는 자료 -> var1 = solve(3, 4) var2 = solve(3, ['Cham'])

-------------------------------------------------------------------------------------------------------------------------------

- 메서드 : 특정 자료에 대해 / 특정 기능을 하는 코드(= 함수)

   특정 자료와 연관 지어 기능 !!! (자료 뒤에 .을 찍어 사용) -> my_list.sort( )

-------------------------------------------------------------------------------------------------------------------------------
- 함수 : 특정 기능을 수행하는 코드(들의 모임)

   ( ) 괄호 안에 매개 변수를 이용해 자료를 전달 -> len(my_list)

   ex) 라면 끓이기 ->  냄비를 가스레인지에 올리기, 가르레인지의 불을 켜기, 냄비에 물을 붓기 ,,,

   1. 함수의 구조

    len() : 자료를 넣으면 그 자료의 길이를 알려줌

    int() : 자료를 넣으면 정수형으로 변환해서 알려줌 

    str() : 자료를 넣으면 문자열로 변환해서 알려줌

   2. 함수의 종류

    1) 내장 함수 : 개발자들이 이미 만들어 둔 함수

     input() : 자료를 입력하는 함수

     print() : 자료를 출력하는 함수,  print()안에 사용자 정의 함수와 인자를 넣으면 그 함수의 반환값(return)을 출력합니다.

     max() : 시퀀스 자료의 최댓값

     min() : 시퀀스 자료의 최솟값

     sum() : 숫자 원소로 이루어진 시퀀스 자료의 합

     len() : 시퀀스 자료의 길이를 구하는 함수

    2) 사용자 정의 함수 : 사용자가 여러 코드를 묶어 새로 만든 함수

     def(ine 정의하다) 키워드를 이용해서 함수 정의

     def 함수이름(매개변수): 매개 변수를 이용해서 함수 내부로 값을 전달,  들여쓰기를 통해 작성, 반환을 통해 외부로 전달
	
	<수행할 명령>

            return 반환값

-------------------------------------------------------------------------------------------------------------------------------

- 딕셔너리: 짝궁이 있는 자료형

   1. 중괄호{}로 묶어서 표현

   dict_zero ={key : value}: key(열쇠처럼 꺼낼 수 있는 도구)를 알면 value(딕셔너리에서 key로 빼낸 자료)를 알 수 있음

   person = {'name' : 'Michael' ,'age' : 10}



   [In] person['name'] , person['age']
         (dic)    (key)

   [out] 'Michael' , 10
            (value)


   2. 자료 추가

   person['hometown'] = 'seoul

   person = {'name' : 'Michael' ,'age' : 10, 'hometown' : 'seoul'}



   3. del을 이용한 원소 삭제

   del person['age']

   person = {'name' : 'Michael', 'hometown' : 'seoul'}

   
    4. key는 변할 수 없는 자료형 => 리스트는 안되고 튜플은 된다(= 튜플은 변하지 않는 자료형이다)

    datas = {[1, 2, 3] : 'Alphabet'} # Error

    datas = {(1, 2, 3) : 'Alphabet'} # Ok

    
    5. 딕셔너리 메서드

    dic.keys( ) 딕셔너리 자료형 모든 key 반환

    dic.values( ) 딕셔너리 자료형 모든 value 반환  

-------------------------------------------------------------------------------------------------------------------------------
- 문자열 + 리스트 + 튜플.... = 시퀀스 자료형: 순서가 있는 자료형

   1. 원소간의 순서가 존재 = 인덱스, 슬라이싱이 가능

   [In] a = 'once'
        b = [ 't', 'w', 'i', 'c', 'e']

   [out] a[1] = n , a[-1]  = e
          b[2:4] = ['i', 'c'] , b[:2] = ['t', 'w']
         
          문자열 슬라이싱 -> 문자열, 리스트 슬라이싱 -> 리스트

   2. 멤버 조회 가능

   [In] 'o' in a 

   [out] True  

   3. 길이 확인 가능

   [In] len(a)

   [out] 4

   4. 연결 연산 = '+' 연산자로 같은 시퀀스 두개를 이어 붙일 수 있음

   [In] ['t', 'w'] + ['o']

   [out] ['t', 'w', 'o']

   5. 반복 연산 = '*' 연산자로 시퀀스 반복 가능

   [In] 'shy' * 3

   [out] shyshyshy

-------------------------------------------------------------------------------------------------------------------------------

- '=' 컴퓨터 메모리 일부분 변수를 만들어 대입을 의미  


- '==' 같다를 의미


- not 논리 값을 뒤집는다
  
  [In] print(not 3 == 4)

  [Out] True

-------------------------------------------------------------------------------------------------------------------------------

OS 

- operating system의 약자로 운영체제에서 제공되는 여러 기능을 파이썬에서 수행 가능

- 파이썬을 이용해 파일을 복사, 디렉터리 생성, 특정 디렉터리 내의 파일 목록 구성을 구하고자 할 때 이용

- os.getcwd( ) : 현재 경로를 얻을 수 있음
  
- os.listdir( 경로 ) : 특정 경로에 존재하는 파일과 디렉터리 목록을 구함

-------------------------------------------------------------------------------------------------------------------------------
반복문

- for문 어떠한 조건이나, 범위 내에서 어떠한 명령을 반복적으로 수행하는 것
 
  for 변수 in 시퀀스:        ->  시퀀스의 원소를 하나씩 변수에 넣어가면서 명령 실행
  <수행할 명령> 
 
  for 변수 in range(a, b):   ->  a이상 b미만의 수를 변수에 넣어가면서 명령을 수행
   <수행할 명령> 


- enumerate 반복문 사용 시 몇 번째 반복문인지 확인이 필요할 때 사용, 인덱스 번호와 컬렉션의 원소를 tuple형태로 반환

   [In] arr = [ 4, 54, 52, 1, 21]

       for index, i in enumerate(arr):
  	 print(f " { index } : { i } ")

   [out] 
	0: 4
	1: 54
	2: 52
	3: 1
	4: 21


- range(a, b) : a 이상 b 미만의 연속된 정수가 담긴 시퀀스를 만들어주는 함수



- range(a) : a번 반복



- list.append( i ): 리스트 마지막 원소 뒤에 추가, 오직 한 개의 자료만 넣을 수 있음

   [In] a = [1]
        
        for i in range(2, 4):
	 a.append(i)
        
        print(a)

   [out] [1, 2, 3]  

- list.insert( i, d ): 인덱스 i에 자료 d를 추가, 오직 한 개의 자료만 넣을 수 있음

   [In] c = [1, 2, 4, 5]
        c.insert(2, 3)

   [out] [1, 2, 3, 4, 5]

- list.remove( d ): 처음 나오는 자료 d를 제거(=중복시 인덱스가 작은 원소 제거)

   [In] d = [3, 1, 2, 3]
        d.remove(3)

   [out] [1, 2, 3]

- list.

-------------------------------------------------------------------------------------------------------------------------------


- print("출력할 내용"): 하나가 아닌 여러자료를 출력할 땐 ,(콤마)를 이용해서 여러 자료를 출력할 수 있음
 
  [In] print(3, 'Hellow!') 

  [Out] 3 Hellow

  [In] print( [50] +[50] ) 
 
  [Out] [50, 50]


-------------------------------------------------------------------------------------------------------------------------------

문자열 

- f - string : 문자열에서 특정 부분만 바꾸고 나머지 부분은 일정하다고 할 때 문자열 포매팅을 이용해 예쁘게 출력 가능
                
   %포매팅과 str.format 방법보다 더 최근에 나온 것

   f ' 문자열 {변수} 문자열 '

   [In] lenth = 5
        print( f '총 페이지수는 {lenth}입니다.' )

   [Out] 총 페이지수는 5입니다.

- find(변수) : 변수 안에 문자열의 구성요소를 검색함, 있으면 있는 문자열 위치를 반환하고 없으면 -1을 반환함

   tt = 'a aa'

   [In] tt.find(' ')

   [Out] 1



- . join( ) : 리스트를 특정 구분자로 포함해 문자열로 변환
 
   lst = ['국어', '수학', '정보', '영어', '체육']

   # 쉼표로 구분하여 문자열로 결합하기

   s = " , ". join(lst)

   print(s)

   [Out] 국어, 수학, 정보, 영어, 체육

-------------------------------------------------------------------------------------------------------------------------------

정규 표현식

- 특정한 규칙을 가진 문자열 패턴을 사용하는 방식


- 데이터 전처리에 있어서 텍스트에서 특정 문자열 검색, 치환, 제거할 때 사용


- 정규식에서는 숫자를 의미하는 기호로 \d를 사용(메타 문자라고 하고 파이썬 예약어 for, int와 비슷하다고 생각하자)


- re.sub('찾을 패턴', '찾은 패턴을 변경할 내용', '원본') : 주어진 문자열(찾을 패턴)에서 일치하는 모든 패턴을 (변경할 내용으로)바꿈
					        두번째 인자는 특정 문자열이거나 함수가 될 수도 있음
        
    [ ] 매타캐릭터 : [ ]안에 들어있는 캐릭터 자체를 나타내며 [abc] : a 또는 b 또는 c

    - : 해당 문자 사이 범위에 속하는 문자 중 하나 [a-d] : a 또는 b 또는 c 또는 d

    ^ : 맨 앞에 사용될 경우에만 해당 문자 패턴이 아닌 것과 매칭 [^a-d] : a 그리고 b 그리고 c 그리고 d 가 아닌 문자열

    text = '010-1234-13*2!1%$^'

    [In] re.sub(r'[%$^*!]', '', text)
    
    [Out] '010-1234-1321'


- re.compile('패턴') : 정규식 객체를 리턴해 줌

   [In] target_list = re.compile('\d{4}\w\w\d+').finditer(txt) 

        패턴{n} = 앞 패턴이 n번 반복해서 나타나는 경우

        패턴{n, m} = 앞 패턴이 최소 n번, 최대 m번 반복해서 나타나는 경우

        \d = [0-9]    |    \D = [^0-9]
    
        \s = [\t \n \r \f \v] 모든 공백 문자와 일치    |    \S = [^\t \n \r \f \v] 모든 비 공백 문자와 일치

        \w = [a-zA-Z0-9_] 모든 영숫자와 일치   |   \W = [^a-zA-Z0-9_] 모든 비 영숫자와 일치 

-------------------------------------------------------------------------------------------------------------------------------