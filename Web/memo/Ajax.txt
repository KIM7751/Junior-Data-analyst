수업소개 

1. 자바스크립트가 도입되면서 웹은 빠른 속도로 정적인 것에서 동적인 것으로

2. 문서에서 애플리케이션으로 발전하기 시작함 

3. 처음에는 페이지 내 사용자의 행동에 따라 웹 페이지가 변화무쌍하게 변경되는 것만으로도 만족스러워함

4. 하지만 인간의 욕심은 끝이 없으며 곧 여러가지 불만이 쏟아져 나옴 

5. 수많은 불만족 중에 우리의 관심사는 웹 페이지의 정보를 부분적으로 변경하는 것임 

6. 오늘날 수많은 검색엔진들이 추천 검색어를 제공하고 있음 

7. 구글에 문자 하나를 넣어봐도 해당 문자로 시작하는 추천검색어가 나오는데 어떻게 가능한 걸까?

8. 웹 페이지가 다운로드 될 때 내가 사용할지도 모르는 모든 추천검색어를 포함해서 다운로드한 것일까?

9. 그럴리 없을 것이 그렇게 해야 된다면 아마 웹 페이지 다운로드에 일 년이 걸릴지도 모름 

10. 이것이 가능한 이유는 "브라우저" 와 "웹 서버" 가 통신을 주고 받을때 보는 개발자 도구를 살펴보자 

11. 문자를 입력하면 우리 몰래 웹 브라우저를 통해서 웹 서버와 통신을 주고 받고 있음 

12. 단어를 완성시키기까지 서버와 계속 통신이 이루어짐 

13. 이것을 가능하게 하는 것이 바로 ajax임 

14. 페이지 전체를 로딩하면 사용자의 관심이 분산될 수 밖에 없음 

15. 또 서버 입장에서도 모든 페이지를 다시 전송했기 때문에 손실이 큼 

16. 이러한 불만 속에 표현한 꽃이 ajax임

17. ajax 기술이 등장하고 5년이 지난 2004년 구글은 지메일이라는 서비스를 선보임

18. 지메일은 마치 데스크 탑 애플리케이션처럼 페이지에 리로드 없이 받은 정보함의 정보를 보여줌

19. 당시 구글이 선보인 일련의 서비스들은 웹에 대한 사람들의 고정관념을 리로드 함

20. 세상은 오랫동안 무명이었던 가치를 알아보게 됨

21. 이때 ajax라는 이름을 갖게 되고 불필요한 정보까지 끄집어내는 그물이 아닌 ajax라는 낚시대를 이용해서 필요한 정보만을 부분적으로

22. 정교하게 낚아채는 낚시꾼이 되어보자 

23. 클라이언트를 사용하는 사용자에게는 좋은 경험을, 서버를 운영하는 생산자에게는 지출을 줄여줄 것임 

----------------------------------------------------------------------------------------------------------------------

수업의 목적

1. web2 JS를 통해 완성된 예제 make_web.html을 이용해보자

2. 링크를 통해 페이지를 전환할때 url을 살펴보면 

3. url도 바뀌고 파일도 바뀜을 알 수 있음 

4. 내부적으로 네트워크엔 무슨일이 일어나는지 살펴보자 

5. F12를 눌러 관리자 창을 띄어 네트워크 탭을 눌러보면 웹 브라우저가 웹 서버가 어떤 정보를 주고 받는가를 모니터링 해주는 도구임

6. 리로드를 해주면 웹 브라우저는 웹 서버와 첫 번째로 make_web.html의 파일을 주고받음

7. 이 파일을 해석해서 웹 페이지를 만드는 과정에서 필요한 여러가지 파일들을 

8. 서버 쪽에 다시 요청해서 가져옴(js, css)

9. 2.html을 리로드하기 위해서 4개의 서버와의 접속이 이뤄졌다라는 것임 

10. 상상력을 발휘해서 3000개라고 가장해보자 내용도 100MB 정도라고 생각했을때

11. 우리가 페이지 전환을 할때마다 모든 정보를 다운 받는다면 얼마나 비효율적인가?

12. 단지 사용자는 1, 2, 3 html을 전환할때마다 바뀌는 컨텐츠 부분만 원하는데 

13. 바로 이렇게 부분적으로 웹 페이지를 갱신 할 수 있도록 도와주는 기술이 "ajax"임

14. ajax가 적용된 페이지의 네트워크 창과 url을 살펴보면 

15. url의 변화가 없고 네트워크 창에 바뀌는 해당 컨텐츠 부분만 다운로드하는 모습을 볼 수 있음 

16. 만약 하나의 웹 페이지를 구성하기 위해 필요한 파일이 1000개이고 전체 용량이 100MB라고 한다면 

17. 페이지를 전환할때마다 모든 파일을 다운로드 받는 것과 그리고 클릭해서 내용이 변경될 때 부분적으로만 내용을 변경하는 것중에

18. 당연히 부분적으로 변경하는게 좋을 것이며 사용자는 변경되는 부분에만 집중할 수 있어서 사용성이 증대되고

19. 필요한 부분만 부분적으로 로드할 수 있기 때문에 서버 뿐만 아니라 웹 브라우저를 사용하는 입장에서도

20. 시간, 비용 네트워크 자원을 절약할 수 있다는 굉장히 중요한 효과가 있음 

21. 이것이 바로 ajax를 배우는 이유임

----------------------------------------------------------------------------------------------------------------------

실습환경 구성 

1. 기본적으로 우리가 JS 과정까지 마치면서 생성한 1, 2, 3, make_web.html을 기초로 함 

2. 웹 브라우저를 파일 열기를 통해서 직접 열면 안됨

3. ajax는 꼭 서버와 통신해야 되기 때문에 보안문제로 인해서 직접 파일을 열면 안됨

4. 웹서버의 문서 디렉토리(apache2/htdocs)에 위치시켜주시면 됨

----------------------------------------------------------------------------------------------------------------------

fetch API 기본 사용법

1. 웹 브라우저에서 JS를 이용해서 웹 서버에 접속해 정보를 가져오는 방법 즉, ajax를 살펴보자

2. ajax를 구현하는 방법 중 최신 방법 중 하나인 fetch API인데 우리는 이것을 사용할 것임

3. htdocs에 테스트를 위한 fetch.html을 만들어줌

4. 간단한 html 코딩을 진행 

5. 버튼을 클릭했을때 fetch API가 동작하게끔 하고 싶음 

	<input type="button" value="fetch">

6. fetch라는 버튼이 하나 생김, 여기에 onclick을 넣어 이벤트를 하나 만들것임

	<input type="button" value="fetch" onclick="alert("hi")>

7. 여기에 ajax를 사용하기 위해 필요한 코드를 기계적으로 타이핑 해보자 

	<input type="button" value="fetch" onclick="
	fetch('css').then(fuction(response){
	response.text().then(function(text){
	alert(text);
		})
	})">

8. 우리가 스마트폰을 쓸 때 원리를 알고 쓰는 경우는 없음 

9. 100% 아는 사람은 없고 어떻게 쓰면 되는지 알고 쓰는 경우가 많음 

10. 이 코드도 원리를 알고 쓰면 좋지만 어떻게 쓰는지 먼저 알아보자

11. 관심을 가져야할 부분과 아닌 부분을 구분해보기 위해 만든 fetch 버튼을 클릭하면 

12. F12 관리자 도구에서 네트워크를 보면 css라는 파일에 다운로드를 받은 모습을 볼 수 있음 

13. css라는 파일에 담긴 내용이 팝업창으로 나오고 있음 

14. 그럼 다른 html이라는 파일을 팝업창에 띄우려면 fetch("css") 부분을 

15. fetch("html")로 바꿔야한다는 것을 알아차릴 수 있음

16. 또한 팝업창을 띄웠던 alert(text)의 위치가 호출되는 부분임을 알 수 있고

17. text라는 변수안에 서버가 응답한 데이터가 들어가 있다는 사실을 숙지하자

18. 이 부분을 응용해보자

	<input type="button" value="fetch" onclick="
	fetch('html').then(fuction(response){
	response.text().then(function(text){
	document.querySelector('article').innerHTML = text;
		})
	})">

19. fetch를 눌렀을때 html이라는 파일의 컨텐츠가 담기는 것을 알 수 있음

20. 우리는 먼저 사용법에 대해서 배웠고 이것의 원리는 차근차근 알아볼 예정임

21. 중요한 것은 사용법만 알아도 얼마든지 쓸 수 있으며 자유도의 한계를 느낄때 원리에 대해서 공부하면됨

22. 학습이 고통스러운 이유는 사용법도 본적이 없는데 원리부터 보면 고통스러워짐

----------------------------------------------------------------------------------------------------------------------

fetch API 요청과 응답 

1. 위에서 사용법을 알아봤다면 이번엔 문법적인 요소를 살펴볼것임 

2. 클라이언트와 서버가 있으면 서로 통신할 클라이언트가 우선 요청을 하는데

	fetch('html)

3. "웹 브라우저야 html 이라는 파일을 서버가 응답하게 해줘" 라고 요청한 것임

4. 웹 브라우저에 개발자 도구를 켜서 확인을 해봐도 html에 접속해서 데이터를 가져오고 있는 것을 볼 수 있음 

5. fetch 라고 하는 함수는 첫 번째 인자로 전달된 데이터를 서버에 요청하는 역할을 함

6. 서버가 적당한 데이터를 꺼내서 응답을 해줘야하는데 응답을 해주는데 시간이 걸릴 수 있음 

7. 많은 시간이 걸릴 수 있고 1시간이 걸린다고 가정해보자

8. 1시간 동안 아무것도 하지 않는 것보다 응답할 때까지 다른일을 하고 있으면 효율적임

9. 그것을 위해 준비되어 있는 기능이 then 임

	fuction callbackme(){
	console.log('response end');
	}
	fetch('html').then(callbackme);

10. "fetch API야 응답이 끝나면 내가 지금부터 정의하는 함수 callbackme라고 하는 이름의 함수를 실행시켜줘" 라고 주문함

11. 그럼 fetch API는 응답이 끝나면 callbackme라는 함수를 실행시키도록 약속되어있는 것임

12. 관리자도구 network와 console창을 키워 확인해보자 

13. fetch 버튼을 누르면 html 파일에 대한 요청을 하고

14. 서버가 응답을 하고 난 후에 callbackme 함수가 실행이 됨

15. console.log를 실행시키면 콘솔창에 어떠한 정보가 출력됨

	fuction callbackme(){
	console.log('response end');
	}
	fetch('html').then(callbackme);
	console.log('2');
	console.log('3');

16. 실행 순서를 보다 직관적으로 살펴보기 위해 console.log를 덧붙임

17. fetch 버튼을 누르고 network와 console창을 확인해보면 

	1 2 response end

18. html 파일을 요청해놓고 console.log 코드들이 실행이 되다가

19. 웹 브라우저가 응답받는게 끝나면 그때 callbackme라는 함수를 호출하게 됨

20. fetch API는 어떤 방식으로 동작하자면 

21. "Asynchronous 비동기" (<-> "synchronous 동기")

22. 만약 동기로 실행됐다면 요청이 시작되고 응답이 끝날 때까지 

23. 후속 console.log가 실행되면 안됨

24. 비동기적 실행은 요청이 실행되고 있는 동안에 다른 코드들이 실행되는 것임

25. 한마디로 동시에 실행된다고 할 수 있음, 

26. 병렬적이라고도 할 수 있음

27. ajax의 a에 해당하는 약자이기도 함 

----------------------------------------------------------------------------------------------------------------------

fetch API response 객체

1. 이전에 작성했던 코드를 보면 then 안에 function이 들어간 괴상한 모양을 하고 있음 

2. 저걸 "익명 함수" 라고 부름 

3. 우리가 만든 callbackme 함수는 이름이 있음

4. 함수가 이름이 필요한 경우는 여기저기서 부를 때 필요함 

5. 하지만 여기서 익명 함수는 then에서만 독점적으로 사용할 것이기 때문에 이름을 가질 필요가 없는 것 

6. 예를 들어보자 

	fuction callbackme(){
	console.log('response end');
	}

	callbackme = function(){
	console.log('reponse end');

7. 이 둘은 같은 뜻을 의미함

	fetch('html').then(callbackme);
	
	fetch('html').then(function(){
	console.log('response end');

8. 익명 함수를 이렇게 사용할 수 있음 

9. fetch API 사용설명서를 잘 보면 then에 callback 함수를 주게 되면 

10. callback 함수가 fetch API를 실행시킬때 저 함수의 첫 번째 인자 값으로 response객체를 주겠습니다라고 적혀있음

	fetch('html').then(function(response){
	console.log(response);
	});
	console.log('1');
	console.log('2');

11. 여기서 인자 값의 이름은 아무렇게나 해도 상관없으나 이 함수가 호출될때 response 객체라고 하는 어떤 입력값으로 주면서 호출할 것이다라고 설명서에 적혀있음

12. 그러면 도대체 response라는 것 안에 어떤 내용이 들어있는가를 console.log를 통해 찍어보자 

13. log를 살펴보면 response라는 객체의 여러 속성값들이 있는데 status가 200이라고 나와 있음 

14. 웹 브라우저와 웹 서버가 통신을 할 때 웹 서버가 응답을 하면서 파일을 잘 찾았다고하면 

15. 200이라고 알려줌 성공이란 뜻임 

16. 요청한 파일이 존재하지 않을때 404를 던짐 not found 찾을 수 없다는 의미임

17. 정리하자면 우리가 html을 요청했고 잘 응답을 받았기 때문에 서버가 200을 알려줬는데 

18. response라는 객체의 status 라는 속성에 값이 200인 것임 

19. 존재하지 않는 파일을 넣을때와 비교해보자 

20. 없는 파일 js를 요청했고 웹 서버가 없으니 404라는 메세지를 브라우저에 보냄 

21. status만 어떻게 가져오냐라고 하면 

	fetch('js').then(function(response){
	console.log(reponse.status);
	});
	console.log('1');
	console.log('2');

22. response 객체의 status 값만 가져옴, 응용하면 경고창 띄우는 것도 가능함 

	fetch('js').then(function(response){
	if(response.status == '404'){
	   alert('Not found')
	}
	});
	console.log('1');
	console.log('2');

23. response라는 객체는 fetch를 통해서 요청을 했을때 웹 서버가 응답한 그 결과를 담고 있는 객체 데이터가

24. response라는 것이고 그 안에는 여러가지 속성이 있으며 서버랑 통신할때 어떤 통신이 이루어졌는지를 알 수 있는 귀중한 단서임 

----------------------------------------------------------------------------------------------------------------------

ajax의 적용

1. 기존에 make_web, 1, 2, 3 총 4개 페이지로 이뤄졌던 웹 브라우저를 

2. 1개 페이지 웹 브라우저로 간단하게 만들어보면서 ajax에 대한 감을 잡아보자

3. make_web에 바뀔 부분과 바뀌지 않는 부분을 생각해보면 되는데 

4. 컨텐츠 부분만 바뀐다는 것을 금방 알 수 있고 

5. 컨텐츠에 해당하는 부분을 fetch api에 맞춰 작성해주면됨

	<a onclick="
	fetch('html').then(function(response){
	response.text().then(function(text){
	document.quertSelector('article').innerHTML = text;
		)}
	)};
	">HTML</a>