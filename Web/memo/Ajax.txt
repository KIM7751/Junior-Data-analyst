수업소개 

1. 자바스크립트가 도입되면서 웹은 빠른 속도로 정적인 것에서 동적인 것으로

2. 문서에서 애플리케이션으로 발전하기 시작함 

3. 처음에는 페이지 내 사용자의 행동에 따라 웹 페이지가 변화무쌍하게 변경되는 것만으로도 만족스러워함

4. 하지만 인간의 욕심은 끝이 없으며 곧 여러가지 불만이 쏟아져 나옴 

5. 수많은 불만족 중에 우리의 관심사는 웹 페이지의 정보를 부분적으로 변경하는 것임 

6. 오늘날 수많은 검색엔진들이 추천 검색어를 제공하고 있음 

7. 구글에 문자 하나를 넣어봐도 해당 문자로 시작하는 추천검색어가 나오는데 어떻게 가능한 걸까?

8. 웹 페이지가 다운로드 될 때 내가 사용할지도 모르는 모든 추천검색어를 포함해서 다운로드한 것일까?

9. 그럴리 없을 것이 그렇게 해야 된다면 아마 웹 페이지 다운로드에 일 년이 걸릴지도 모름 

10. 이것이 가능한 이유는 "브라우저" 와 "웹 서버" 가 통신을 주고 받을때 보는 개발자 도구를 살펴보자 

11. 문자를 입력하면 우리 몰래 웹 브라우저를 통해서 웹 서버와 통신을 주고 받고 있음 

12. 단어를 완성시키기까지 서버와 계속 통신이 이루어짐 

13. 이것을 가능하게 하는 것이 바로 ajax임 

14. 페이지 전체를 로딩하면 사용자의 관심이 분산될 수 밖에 없음 

15. 또 서버 입장에서도 모든 페이지를 다시 전송했기 때문에 손실이 큼 

16. 이러한 불만 속에 표현한 꽃이 ajax임

17. ajax 기술이 등장하고 5년이 지난 2004년 구글은 지메일이라는 서비스를 선보임

18. 지메일은 마치 데스크 탑 애플리케이션처럼 페이지에 리로드 없이 받은 정보함의 정보를 보여줌

19. 당시 구글이 선보인 일련의 서비스들은 웹에 대한 사람들의 고정관념을 리로드 함

20. 세상은 오랫동안 무명이었던 가치를 알아보게 됨

21. 이때 ajax라는 이름을 갖게 되고 불필요한 정보까지 끄집어내는 그물이 아닌 ajax라는 낚시대를 이용해서 필요한 정보만을 부분적으로

22. 정교하게 낚아채는 낚시꾼이 되어보자 

23. 클라이언트를 사용하는 사용자에게는 좋은 경험을, 서버를 운영하는 생산자에게는 지출을 줄여줄 것임 

----------------------------------------------------------------------------------------------------------------------

수업의 목적

1. web2 JS를 통해 완성된 예제 make_web.html을 이용해보자

2. 링크를 통해 페이지를 전환할때 url을 살펴보면 

3. url도 바뀌고 파일도 바뀜을 알 수 있음 

4. 내부적으로 네트워크엔 무슨일이 일어나는지 살펴보자 

5. F12를 눌러 관리자 창을 띄어 네트워크 탭을 눌러보면 웹 브라우저가 웹 서버가 어떤 정보를 주고 받는가를 모니터링 해주는 도구임

6. 리로드를 해주면 웹 브라우저는 웹 서버와 첫 번째로 make_web.html의 파일을 주고받음

7. 이 파일을 해석해서 웹 페이지를 만드는 과정에서 필요한 여러가지 파일들을 

8. 서버 쪽에 다시 요청해서 가져옴(js, css)

9. 2.html을 리로드하기 위해서 4개의 서버와의 접속이 이뤄졌다라는 것임 

10. 상상력을 발휘해서 3000개라고 가장해보자 내용도 100MB 정도라고 생각했을때

11. 우리가 페이지 전환을 할때마다 모든 정보를 다운 받는다면 얼마나 비효율적인가?

12. 단지 사용자는 1, 2, 3 html을 전환할때마다 바뀌는 컨텐츠 부분만 원하는데 

13. 바로 이렇게 부분적으로 웹 페이지를 갱신 할 수 있도록 도와주는 기술이 "ajax"임

14. ajax가 적용된 페이지의 네트워크 창과 url을 살펴보면 

15. url의 변화가 없고 네트워크 창에 바뀌는 해당 컨텐츠 부분만 다운로드하는 모습을 볼 수 있음 

16. 만약 하나의 웹 페이지를 구성하기 위해 필요한 파일이 1000개이고 전체 용량이 100MB라고 한다면 

17. 페이지를 전환할때마다 모든 파일을 다운로드 받는 것과 그리고 클릭해서 내용이 변경될 때 부분적으로만 내용을 변경하는 것중에

18. 당연히 부분적으로 변경하는게 좋을 것이며 사용자는 변경되는 부분에만 집중할 수 있어서 사용성이 증대되고

19. 필요한 부분만 부분적으로 로드할 수 있기 때문에 서버 뿐만 아니라 웹 브라우저를 사용하는 입장에서도

20. 시간, 비용 네트워크 자원을 절약할 수 있다는 굉장히 중요한 효과가 있음 

21. 이것이 바로 ajax를 배우는 이유임

----------------------------------------------------------------------------------------------------------------------

실습환경 구성 

1. 기본적으로 우리가 JS 과정까지 마치면서 생성한 1, 2, 3, make_web.html을 기초로 함 

2. 웹 브라우저를 파일 열기를 통해서 직접 열면 안됨

3. ajax는 꼭 서버와 통신해야 되기 때문에 보안문제로 인해서 직접 파일을 열면 안됨

4. 웹서버의 문서 디렉토리(apache2/htdocs)에 위치시켜주시면 됨

----------------------------------------------------------------------------------------------------------------------

fetch API 기본 사용법

1. 웹 브라우저에서 JS를 이용해서 웹 서버에 접속해 정보를 가져오는 방법 즉, ajax를 살펴보자

2. ajax를 구현하는 방법 중 최신 방법 중 하나인 fetch API인데 우리는 이것을 사용할 것임

3. htdocs에 테스트를 위한 fetch.html을 만들어줌

4. 간단한 html 코딩을 진행 

5. 버튼을 클릭했을때 fetch API가 동작하게끔 하고 싶음 

	<input type="button" value="fetch">

6. fetch라는 버튼이 하나 생김, 여기에 onclick을 넣어 이벤트를 하나 만들것임

	<input type="button" value="fetch" onclick="alert("hi")>

7. 여기에 ajax를 사용하기 위해 필요한 코드를 기계적으로 타이핑 해보자 

	<input type="button" value="fetch" onclick="
	fetch('css').then(fuction(response){
	response.text().then(function(text){
	alert(text);
		})
	})">

8. 우리가 스마트폰을 쓸 때 원리를 알고 쓰는 경우는 없음 

9. 100% 아는 사람은 없고 어떻게 쓰면 되는지 알고 쓰는 경우가 많음 

10. 이 코드도 원리를 알고 쓰면 좋지만 어떻게 쓰는지 먼저 알아보자

11. 관심을 가져야할 부분과 아닌 부분을 구분해보기 위해 만든 fetch 버튼을 클릭하면 

12. F12 관리자 도구에서 네트워크를 보면 css라는 파일에 다운로드를 받은 모습을 볼 수 있음 

13. css라는 파일에 담긴 내용이 팝업창으로 나오고 있음 

14. 그럼 다른 html이라는 파일을 팝업창에 띄우려면 fetch("css") 부분을 

15. fetch("html")로 바꿔야한다는 것을 알아차릴 수 있음

16. 또한 팝업창을 띄웠던 alert(text)의 위치가 호출되는 부분임을 알 수 있고

17. text라는 변수안에 서버가 응답한 데이터가 들어가 있다는 사실을 숙지하자

18. 이 부분을 응용해보자

	<input type="button" value="fetch" onclick="
	fetch('html').then(fuction(response){
	response.text().then(function(text){
	document.querySelector('article').innerHTML = text;
		})
	})">

19. fetch를 눌렀을때 html이라는 파일의 컨텐츠가 담기는 것을 알 수 있음

20. 우리는 먼저 사용법에 대해서 배웠고 이것의 원리는 차근차근 알아볼 예정임

21. 중요한 것은 사용법만 알아도 얼마든지 쓸 수 있으며 자유도의 한계를 느낄때 원리에 대해서 공부하면됨

22. 학습이 고통스러운 이유는 사용법도 본적이 없는데 원리부터 보면 고통스러워짐

----------------------------------------------------------------------------------------------------------------------

fetch API 요청과 응답 

1. 위에서 사용법을 알아봤다면 이번엔 문법적인 요소를 살펴볼것임 

2. 클라이언트와 서버가 있으면 서로 통신할 클라이언트가 우선 요청을 하는데

	fetch('html)

3. "웹 브라우저야 html 이라는 파일을 서버가 응답하게 해줘" 라고 요청한 것임

4. 웹 브라우저에 개발자 도구를 켜서 확인을 해봐도 html에 접속해서 데이터를 가져오고 있는 것을 볼 수 있음 

5. fetch 라고 하는 함수는 첫 번째 인자로 전달된 데이터를 서버에 요청하는 역할을 함

6. 서버가 적당한 데이터를 꺼내서 응답을 해줘야하는데 응답을 해주는데 시간이 걸릴 수 있음 

7. 많은 시간이 걸릴 수 있고 1시간이 걸린다고 가정해보자

8. 1시간 동안 아무것도 하지 않는 것보다 응답할 때까지 다른일을 하고 있으면 효율적임

9. 그것을 위해 준비되어 있는 기능이 then 임

	fuction callbackme(){
	console.log('response end');
	}
	fetch('html').then(callbackme);

10. "fetch API야 응답이 끝나면 내가 지금부터 정의하는 함수 callbackme라고 하는 이름의 함수를 실행시켜줘" 라고 주문함

11. 그럼 fetch API는 응답이 끝나면 callbackme라는 함수를 실행시키도록 약속되어있는 것임

12. 관리자도구 network와 console창을 키워 확인해보자 

13. fetch 버튼을 누르면 html 파일에 대한 요청을 하고

14. 서버가 응답을 하고 난 후에 callbackme 함수가 실행이 됨

15. console.log를 실행시키면 콘솔창에 어떠한 정보가 출력됨

	fuction callbackme(){
	console.log('response end');
	}
	fetch('html').then(callbackme);
	console.log('2');
	console.log('3');

16. 실행 순서를 보다 직관적으로 살펴보기 위해 console.log를 덧붙임

17. fetch 버튼을 누르고 network와 console창을 확인해보면 

	1 2 response end

18. html 파일을 요청해놓고 console.log 코드들이 실행이 되다가

19. 웹 브라우저가 응답받는게 끝나면 그때 callbackme라는 함수를 호출하게 됨

20. fetch API는 어떤 방식으로 동작하자면 

21. "Asynchronous 비동기" (<-> "synchronous 동기")

22. 만약 동기로 실행됐다면 요청이 시작되고 응답이 끝날 때까지 

23. 후속 console.log가 실행되면 안됨

24. 비동기적 실행은 요청이 실행되고 있는 동안에 다른 코드들이 실행되는 것임

25. 한마디로 동시에 실행된다고 할 수 있음, 

26. 병렬적이라고도 할 수 있음

27. ajax의 a에 해당하는 약자이기도 함 

----------------------------------------------------------------------------------------------------------------------

fetch API response 객체

1. 이전에 작성했던 코드를 보면 then 안에 function이 들어간 괴상한 모양을 하고 있음 

2. 저걸 "익명 함수" 라고 부름 

3. 우리가 만든 callbackme 함수는 이름이 있음

4. 함수가 이름이 필요한 경우는 여기저기서 부를 때 필요함 

5. 하지만 여기서 익명 함수는 then에서만 독점적으로 사용할 것이기 때문에 이름을 가질 필요가 없는 것 

6. 예를 들어보자 

	fuction callbackme(){
	console.log('response end');
	}

	callbackme = function(){
	console.log('reponse end');

7. 이 둘은 같은 뜻을 의미함

	fetch('html').then(callbackme);
	
	fetch('html').then(function(){
	console.log('response end');

8. 익명 함수를 이렇게 사용할 수 있음 

9. fetch API 사용설명서를 잘 보면 then에 callback 함수를 주게 되면 

10. callback 함수가 fetch API를 실행시킬때 저 함수의 첫 번째 인자 값으로 response객체를 주겠습니다라고 적혀있음

	fetch('html').then(function(response){
	console.log(response);
	});
	console.log('1');
	console.log('2');

11. 여기서 인자 값의 이름은 아무렇게나 해도 상관없으나 이 함수가 호출될때 response 객체라고 하는 어떤 입력값으로 주면서 호출할 것이다라고 설명서에 적혀있음

12. 그러면 도대체 response라는 것 안에 어떤 내용이 들어있는가를 console.log를 통해 찍어보자 

13. log를 살펴보면 response라는 객체의 여러 속성값들이 있는데 status가 200이라고 나와 있음 

14. 웹 브라우저와 웹 서버가 통신을 할 때 웹 서버가 응답을 하면서 파일을 잘 찾았다고하면 

15. 200이라고 알려줌 성공이란 뜻임 

16. 요청한 파일이 존재하지 않을때 404를 던짐 not found 찾을 수 없다는 의미임

17. 정리하자면 우리가 html을 요청했고 잘 응답을 받았기 때문에 서버가 200을 알려줬는데 

18. response라는 객체의 status 라는 속성에 값이 200인 것임 

19. 존재하지 않는 파일을 넣을때와 비교해보자 

20. 없는 파일 js를 요청했고 웹 서버가 없으니 404라는 메세지를 브라우저에 보냄 

21. status만 어떻게 가져오냐라고 하면 

	fetch('js').then(function(response){
	console.log(reponse.status);
	});
	console.log('1');
	console.log('2');

22. response 객체의 status 값만 가져옴, 응용하면 경고창 띄우는 것도 가능함 

	fetch('js').then(function(response){
	if(response.status == '404'){
	   alert('Not found')
	}
	});
	console.log('1');
	console.log('2');

23. response라는 객체는 fetch를 통해서 요청을 했을때 웹 서버가 응답한 그 결과를 담고 있는 객체 데이터가

24. response라는 것이고 그 안에는 여러가지 속성이 있으며 서버랑 통신할때 어떤 통신이 이루어졌는지를 알 수 있는 귀중한 단서임 

----------------------------------------------------------------------------------------------------------------------

ajax의 적용

1. 기존에 make_web, 1, 2, 3 총 4개 페이지로 이뤄졌던 웹 브라우저를 

2. 1개 페이지 웹 브라우저로 간단하게 만들어보면서 ajax에 대한 감을 잡아보자

3. make_web에 바뀔 부분과 바뀌지 않는 부분을 생각해보면 되는데 

4. 컨텐츠 부분만 바뀐다는 것을 금방 알 수 있고 

5. 컨텐츠에 해당하는 부분을 fetch api에 맞춰 작성해주면됨

	<a onclick="
	fetch('html').then(function(response){
	response.text().then(function(text){
	document.quertSelector('article').innerHTML = text;
		)}
	)};
	">HTML</a>

----------------------------------------------------------------------------------------------------------------------

리팩토링 함수화

1. ajax의 본질을 살펴보았으니 본질을 활용해서 애플리케이션을 발전, 개선 시켜보자

2. 개발 과정에서 우리가 마주하는 흔한 문제로 "코드 중복"임

3. 구분을 해야할 사항은 중복인 부분과 아닌 부분을 나누는 것임

4. 그 동안 코드를 정리하는 것은 "함수"를 이용해 왔었음 

5. html 끝자락에 script 태그를 열어주고 함수를 만들어보자

6. 함수의 목표는 코드를 재활용하는 것임을 인지하자

	function fetchPage(name) {
	fetch(name).then(function(response){
	response.text().then(function(text){
	document.querySelector('article').innerHTML = text;
			})
 		});
	}

7. 위 코드에서 바뀔 수 있는 부분인 fetch 인자를 함수 매개변수로 지정해주면 수월하게 끝낼 수 있음

8. 훨씬 더 가독성이 높고 유지보수하기 쉬우며 코드가 줄어듦

----------------------------------------------------------------------------------------------------------------------

fragment identifier를 이용한 초기 페이지 기능 구현 

1. 지난 시간까지 ajax에 가장 본질적인 기능을 살펴보았고

2. 지금부터는 ajax를 구현 했을 때 우리가 직면할 수 있는 여러 부작용을 완화해 나가는 과정을 살펴볼 것임

3. 우선 해당 페이지를 각각의 다른 컨텐츠를 가리키는 링크 리스트에 밑줄이 없음 

4. 첫번째로 css로 꾸밀수도 있겠지만 링크 순수한 상태로 활성화되면 좋을 것 같음

5. 두번째는 사용자가 들어와서 하나씩 네비게이션 해서 정보를 보는것 뿐만 아니라 

6. 주소가 페이지 별로 달라지는걸 통해서 주소를 공유하고 싶음 

7. 이 문제를 해결하기 위해서 생긴 원시적인 해결책을 먼저 알아보자

8. # 해쉬라는 것을 먼저 알아볼것임 

9. 우리가 어떤 페이지에 접근할 때는 저런 url을 통해서 접근할 수 있음 

10. 그런데 이런 경우 페이지 안에서 어떤 특정한 부분으로 접근하는 방법이 있음 

11. hash.html이라는 파일을 만들고 그곳에 <p></p> 태그를 이용해 컨텐츠를 넣어보자

12. 총 세문단을 만들고 이 페이지에 세번째 문단에 접근할 수 있도록 만들고 싶음 

13. 이때 사용하는 것을 # 해쉬기능이라고 함 

14. 쉽게 말해 북마크를 한다고 보면됨

15. 그렇게 하기위해서는 식별을 원하는 태그에 id 값을 주는 것임 

16. 그리고 url 맨 끝에다가 #id값을 부여하면 페이지가 리로드 되지 않고 

17. 페이지 해쉬값 부분으로 이동함 

18. 이렇게 다른사람에게도 url을 공유할 수 있음 

19. 해쉬에 해당하는 부분을 조각, fragment라고 하고 

20. 조각을 식별한다고 해서 fragment identifier라고 함 

21. <a href = "#three">three</a>를 작성해봐도 바로 이동함을 볼 수 있음 

22. 이렇게 url임을 식별하는 색깔을 입힐 수 있고

23. 해쉬 값이 무엇이냐에 따라서 ajax로 다른 페이지를 로드해서 시작되는 페이지를 세팅할 수 있음 

24. url 상의 해쉬값을 가져오는 방법을 살펴보자  

	<script></script>

25. 직접 검색해보자 how to get hash from url js

	if(location.hash) {
	console.log(location.hash);
 	 // Fragment exists
	} else {
  	// Fragment doesn't exist
	}

26. location.hash라는 함수는 주소창의 #이하의 값을 읽어온다고 생각하시면 됨

27. 실제로 웹 문서에 id태그가 존재하느냐와 상관없이 해당 id 값이 없으면 이동할 id태그의 값이 없으니 아무 반응도 하지 않음

27. 정리하자면 # 해쉬를 이용해 북마크를 달면 ajax를 활용한 내가 공유하고 싶은 선택 페이지 URL이 생성되고 구현할 수 있음 

28. location.hash로 출력되는 #three에서 #을 떼고 싶으면 

29. how to get substring이라고 검색해보자

	if(location.hash) {
	console.log(location.hash.substring(1);
	} else {
	}

30. three만 출력하는 것 확인할 수 있음 
 
31. 이번 시간에 fragment, hash, fragment identifier

32. 자바스크립트를 통해 위 값들을 가져오는 방법을 배워보았음 

33. 추가적으로 # 해쉬 단독 사용은 북마크 기능이기 때문에 

34. 약간 용도를 구분하기위해서 #! 해쉬뱅이라는 것을 사용함

35. 해쉬뱅 즉, fregment identifier를 만들어 외부에 공유할 수 있는 url을 만듦

	make_web.html/

36. 하지만 해당 url을 통해 곧바로 접속해보면 초기 화면이 뜨게됨

37. 왜 그럴까?

38. 각각의 페이지를 다운로드하는 js oncklick과 링크를 생성하는 a 태그 href = 가 별개이기 때문임

39. 따라서 이 둘을 엮어줘야함 

	if (location.hash) {
		fetchPage(location.hash.substr(2))
	} else {
	}

40. script 태그안에 넣어주면 우리의 문제가 해결됨

41. 하지만 이렇게 진행하는 작업에도 맹점이 하나 존재함

42. 검색엔진최적화가 안된다는 점임

43. 검색엔진은 웹페이지를 다운로드 받아서 그걸 분석해야하는데 

44. 이 웹 페이지 자체는 실제 내용이 없음, 텍스트니깐!

45. 내용은 백엔드에서 동적으로 가져오는 것임 

46. 현재 해쉬뱅을 이용한 구현한 방식은 거의 사용되지 않고 

47. pjax라고 하는 기술을 많이 이용함 

48. 우리가 배운 ajax의 단점들을 보완한 진화된 방식의 기술임

49. 나중에 필요할 때 추가적으로 공부하면 됨 
 
----------------------------------------------------------------------------------------------------------------------

데이터와 애플리케이션(로직) 구분하여 구현하기 1

1. 프로그래머들은 데이터와 애플리케이션을 구분함 

2. 현재 우리가 초기화면인 make_web.html은 데이터, 로직이 혼재되어있음

3. 데이터와 애플리케이션이 섞여 있다는 뜻임

4. 데이터의 특징은 바뀔 수 있다는 점임

	<ol>
            <li><a href="#!html" onclick="fetchPage('html')">HTML</a></li>
            <li><a href="#!css" onclick="fetchPage('css')">CSS</a></li>
            <li><a href="#!javascript" onclick="fetchPage	('javascript')">JavaScript</a></li>        
        	</ol>

5. 애플리케이션의 일부인 코드도 바꿀 수 있지만 

6. 한번 작성해놓으면 알아서 논리적으로 돌아가는 것임

7. 데이터는 애플리케이션을 사용하다보면 바뀌고 최신화됨

8. 따라서 위에 작성한 코드는 데이터로써 바뀔 수 있는 성격을 갖고있기 때문에

9. 바깥쪽으로 분리하고 싶은 것임 

10. 그래야만 데이터가 바뀌었다고 애플리케이션을 뜯어고치는 부끄러운 상황이 나오지 않는 것임 

11. 방법으로는 해당 코드를 복사해 list라는 파일을 하나 만들어 붙여넣기를 진행 

12. 리스트라는 파일을 읽어서 거기 있는 내용을 id값이 nav인 태그 안쪽에 넣는 작업이 목표가 될 것임
	
	fetch('list').then(function(response) {
	response.text().then(function(text) {
	document.querySelector('#nav').innerHTML = text;

13. list파일에서 자유롭게 추가 또는 제거할 리스트 목록을 편집할 수 있음 

14. 이제 더이상 make_web.html 파일을 수정하지 않음 

15. 그리고 데이터가 들어있는 list파일을 수정하는 것을 통해서 

16. 애플리케이션 입장에서는 사용자들이 make_web.html을 수정하다가 

17. 생길 수 있는 사고를 방지할 수 있고 컨텐츠를 입력하는 입장에서는 

18. 컨텐츠 입력을 어디에 어떻게 해야하는가 또는 실수로 다른 부분을 망가뜨리진않을까라는 고민에서 자유로울 수 있음 

19. 이렇게 데이터와 애플리케이션을 구분해 ajax를 활용한 구현을 진행함

----------------------------------------------------------------------------------------------------------------------

데이터와 애플리케이션(로직) 구분하여 구현하기 2

1. 분리한 데이터들의 모음 list 파일을 살펴보면 중복이 있음을 알 수 있음
	
	list file
	<li><a href= ~	

2. 중복들을 다 없애버리고 컴팩트하게 본질만 남기려면 어떻게 해야할까?

	list file
	html, css, javascript, ajax

3. 결론부터 이야기하자면 list file에서 위와 같이 나열된 문자들에 대해서

4. 콤마를 구분자로 각각에 데이터를 하나씩 불러와 sctipt 태그 안에 innerHTML 처리 하면됨

	fetch('list').then(function(response){
	response.text().then(function(text){
	console.log(text);

	html, css, javascript

5. 위와 같이 log를 찍어보면 list 파일 안에 텍스트가 호출됨 

6. 여기서 생각해보자 데이터 문자열을 뭐로 바꾸면 편할까?

7. 반복적인 작업을 할때 세트로 가족처럼 쓰는 것이 "배열"이였음

8. 콤마를 기준으로 각각 항목들을 원소로하는 배열을 만들 수 있다면

9. 우리는 배열에 담겨있는 데이터를 반복문에 따라 하나씩 꺼내서 사용가능함

10. 그때 사용하는 것이 "split"임

	var items = text.split(",")

11. 텍스트에 있는 문자열을 콤마를 기준으로 해서 하나하나 쪼개서 배열을 만드는 표현식임

	console.log(items);

12. log를 확인해보면 ['html', 'css', 'javascript', 'ajax'] 배열로 출력됨

13. 배열을 만들었으니 반복문이 사용가능함 

	fetch.('list').then(function(response){
	response.text().then.(function(text){
	
	var items = text.split(",");
	var i = 0;
	while (i < items.length) {
		var item = items[i]
		console.log(item);
		i += 1;
		}
	document.querySelector("#nav").innerHTML = text;
		})
	})

14. html 태그도 넣어 만들어보자

	fetch.('list').then(function(response){
	response.text().then.(function(text){
	
	var items = text.split(",");
	var i = 0;
		while (i < items.length) {
		var item = items[i]
		var tag = '<li><a>'+item+'</li></a>'
		i += 1;
		}
	document.querySelector("#nav").innerHTML = text;
		})
	})

15. list 모습까지 갖추려면 빈 문자열이 필요함, 왜냐하면 반복문으로 태그를 넣어 만든 문자열을 보존하기 위해서임

16. 만약 빈 문자열이 없다면 반복문의 맨 마지막 값만 남게됨 

17. 한마디로 담는 그릇이라고 보면됨
	
	fetch.('list').then(function(response){
	response.text().then.(function(text){
	
		var items = text.split(",");
		var i = 0;
		var tags = ' ';
		while (i < items.length) {
		var item = items[i]
		var tag = '<li><a>'+item+'</li></a>'
		tags = tags + tag
		i += 1;
		}
	console.log(tags);
	document.querySelector("#nav").innerHTML = tags;
		})
	})

  

  
